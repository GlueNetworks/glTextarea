/*! 
  glTextarea v(0.0.7) 
  (c) 2013-2015
  https://gluenetworks.kilnhg.com/Code/Web-Development
  Release Date: 2015-03-06 
*/

// Copyright 2009-2012 by contributors, MIT License
// vim: ts=4 sts=4 sw=4 expandtab
// Module systems magic dance
!function(definition) {
    // RequireJS
    "function" == typeof define ? define(definition) : "function" == typeof YUI ? YUI.add("es5", definition) : definition();
}(function() {
    /**
 * Brings an environment as close to ECMAScript 5 compliance
 * as is possible with the facilities of erstwhile engines.
 *
 * Annotated ES5: http://es5.github.com/ (specific links below)
 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
 */
    //
    // Function
    // ========
    //
    // ES-5 15.3.4.5
    // http://es5.github.com/#x15.3.4.5
    function Empty() {}
    //
    // Util
    // ======
    //
    // ES5 9.4
    // http://es5.github.com/#x9.4
    // http://jsperf.com/to-integer
    function toInteger(n) {
        // isNaN
        return n = +n, n !== n ? n = 0 : 0 !== n && n !== 1 / 0 && n !== -(1 / 0) && (n = (n > 0 || -1) * Math.floor(Math.abs(n))), 
        n;
    }
    function isPrimitive(input) {
        var type = typeof input;
        return null === input || "undefined" === type || "boolean" === type || "number" === type || "string" === type;
    }
    function toPrimitive(input) {
        var val, valueOf, toString;
        if (isPrimitive(input)) return input;
        if (valueOf = input.valueOf, "function" == typeof valueOf && (val = valueOf.call(input), 
        isPrimitive(val))) return val;
        if (toString = input.toString, "function" == typeof toString && (val = toString.call(input), 
        isPrimitive(val))) return val;
        throw new TypeError();
    }
    Function.prototype.bind || (Function.prototype.bind = function(that) {
        // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if ("function" != typeof target) throw new TypeError("Function.prototype.bind called on incompatible " + target);
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = _Array_slice_.call(arguments, 1), bound = function() {
            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.
                var result = target.apply(this, args.concat(_Array_slice_.call(arguments)));
                return Object(result) === result ? result : this;
            }
            // 15.3.4.5.1 [[Call]]
            // When the [[Call]] internal method of a function object, F,
            // which was created using the bind function is called with a
            // this value and a list of arguments ExtraArgs, the following
            // steps are taken:
            // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
            //   property.
            // 2. Let boundThis be the value of F's [[BoundThis]] internal
            //   property.
            // 3. Let target be the value of F's [[TargetFunction]] internal
            //   property.
            // 4. Let args be a new list containing the same values as the
            //   list boundArgs in the same order followed by the same
            //   values as the list ExtraArgs in the same order.
            // 5. Return the result of calling the [[Call]] internal method
            //   of target providing boundThis as the this value and
            //   providing args as the arguments.
            // equiv: target.call(this, ...boundArgs, ...args)
            return target.apply(that, args.concat(_Array_slice_.call(arguments)));
        };
        // XXX bound.length is never writable, so don't even try
        //
        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.
        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.
        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.
        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.
        // 22. Return F.
        // Clean up dangling references.
        return target.prototype && (Empty.prototype = target.prototype, bound.prototype = new Empty(), 
        Empty.prototype = null), bound;
    });
    // Shortcut to an often accessed properties, in order to avoid multiple
    // dereference that costs universally.
    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
    // us it in defining shortcuts.
    var defineGetter, defineSetter, lookupGetter, lookupSetter, supportsAccessors, call = Function.prototype.call, prototypeOfArray = Array.prototype, prototypeOfObject = Object.prototype, _Array_slice_ = prototypeOfArray.slice, _toString = call.bind(prototypeOfObject.toString), owns = call.bind(prototypeOfObject.hasOwnProperty);
    //
    // Array
    // =====
    //
    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.12
    // Default value for second param
    // [bugfix, ielt9, old browsers]
    // IE < 9 bug: [1,2].splice(0).join("") == "" but should be "12"
    if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__")) && (defineGetter = call.bind(prototypeOfObject.__defineGetter__), 
    defineSetter = call.bind(prototypeOfObject.__defineSetter__), lookupGetter = call.bind(prototypeOfObject.__lookupGetter__), 
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__)), 2 != [ 1, 2 ].splice(0).length) {
        var array_splice = Array.prototype.splice;
        //IE 6/7
        Array.prototype.splice = function() {
            // test IE < 9 to splice bug - see issue #138
            function makeArray(l) {
                for (var a = []; l--; ) a.unshift(l);
                return a;
            }
            var lengthBefore, array = [];
            // add one element
            //20
            // add one element
            return array.splice.bind(array, 0, 0).apply(null, makeArray(20)), array.splice.bind(array, 0, 0).apply(null, makeArray(26)), 
            lengthBefore = array.length, array.splice(5, 0, "XXX"), lengthBefore + 1 == array.length ? !0 : void 0;
        }() ? function(start, deleteCount) {
            return arguments.length ? array_splice.apply(this, [ void 0 === start ? 0 : start, void 0 === deleteCount ? this.length - start : deleteCount ].concat(_Array_slice_.call(arguments, 2))) : [];
        } : function(start, deleteCount) {
            var result, args = _Array_slice_.call(arguments, 2), addElementsCount = args.length;
            if (!arguments.length) return [];
            if (void 0 === start && (// default
            start = 0), void 0 === deleteCount && (// default
            deleteCount = this.length - start), addElementsCount > 0) {
                if (0 >= deleteCount) {
                    if (start == this.length) // tiny optimisation #1
                    return this.push.apply(this, args), [];
                    if (0 == start) // tiny optimisation #2
                    return this.unshift.apply(this, args), [];
                }
                // Array.prototype.splice implementation
                // delete part
                // right part
                // left part
                // delete all items from this array and replace it to 'left part' + _Array_slice_.call(arguments, 2) + 'right part'
                return result = _Array_slice_.call(this, start, start + deleteCount), args.push.apply(args, _Array_slice_.call(this, start + deleteCount, this.length)), 
                args.unshift.apply(args, _Array_slice_.call(this, 0, start)), args.unshift(0, this.length), 
                array_splice.apply(this, args), result;
            }
            return array_splice.call(this, start, deleteCount);
        };
    }
    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.13
    // Return len+argCount.
    // [bugfix, ielt8]
    // IE < 8 bug: [].unshift(0) == undefined but should be "1"
    if (1 != [].unshift(0)) {
        var array_unshift = Array.prototype.unshift;
        Array.prototype.unshift = function() {
            return array_unshift.apply(this, arguments), this.length;
        };
    }
    // ES5 15.4.3.2
    // http://es5.github.com/#x15.4.3.2
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
    Array.isArray || (Array.isArray = function(obj) {
        return "[object Array]" == _toString(obj);
    });
    // The IsCallable() check in the Array functions
    // has been replaced with a strict check on the
    // internal class of the object to trap cases where
    // the provided function was actually a regular
    // expression literal, which in V8 and
    // JavaScriptCore is a typeof "function".  Only in
    // V8 are regular expression literals permitted as
    // reduce parameters, so it is desirable in the
    // general case for the shim to match the more
    // strict and common behavior of rejecting regular
    // expressions.
    // ES5 15.4.4.18
    // http://es5.github.com/#x15.4.4.18
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
    // Check failure of by-index access of string characters (IE < 9)
    // and failure of `0 in boxedString` (Rhino)
    var boxedString = Object("a"), splitString = "a" != boxedString[0] || !(0 in boxedString);
    //
    // Object
    // ======
    //
    // ES5 15.2.3.14
    // http://es5.github.com/#x15.2.3.14
    if (Array.prototype.forEach || (Array.prototype.forEach = function(fun) {
        var object = toObject(this), self = splitString && "[object String]" == _toString(this) ? this.split("") : object, thisp = arguments[1], i = -1, length = self.length >>> 0;
        // If no callback function or if callback is not a callable function
        if ("[object Function]" != _toString(fun)) throw new TypeError();
        for (;++i < length; ) i in self && // Invoke the callback function with call, passing arguments:
        // context, property value, property key, thisArg object
        // context
        fun.call(thisp, self[i], i, object);
    }), // ES5 15.4.4.19
    // http://es5.github.com/#x15.4.4.19
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
    Array.prototype.map || (Array.prototype.map = function(fun) {
        var object = toObject(this), self = splitString && "[object String]" == _toString(this) ? this.split("") : object, length = self.length >>> 0, result = Array(length), thisp = arguments[1];
        // If no callback function or if callback is not a callable function
        if ("[object Function]" != _toString(fun)) throw new TypeError(fun + " is not a function");
        for (var i = 0; length > i; i++) i in self && (result[i] = fun.call(thisp, self[i], i, object));
        return result;
    }), // ES5 15.4.4.20
    // http://es5.github.com/#x15.4.4.20
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
    Array.prototype.filter || (Array.prototype.filter = function(fun) {
        var value, object = toObject(this), self = splitString && "[object String]" == _toString(this) ? this.split("") : object, length = self.length >>> 0, result = [], thisp = arguments[1];
        // If no callback function or if callback is not a callable function
        if ("[object Function]" != _toString(fun)) throw new TypeError(fun + " is not a function");
        for (var i = 0; length > i; i++) i in self && (value = self[i], fun.call(thisp, value, i, object) && result.push(value));
        return result;
    }), // ES5 15.4.4.16
    // http://es5.github.com/#x15.4.4.16
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
    Array.prototype.every || (Array.prototype.every = function(fun) {
        var object = toObject(this), self = splitString && "[object String]" == _toString(this) ? this.split("") : object, length = self.length >>> 0, thisp = arguments[1];
        // If no callback function or if callback is not a callable function
        if ("[object Function]" != _toString(fun)) throw new TypeError(fun + " is not a function");
        for (var i = 0; length > i; i++) if (i in self && !fun.call(thisp, self[i], i, object)) return !1;
        return !0;
    }), // ES5 15.4.4.17
    // http://es5.github.com/#x15.4.4.17
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
    Array.prototype.some || (Array.prototype.some = function(fun) {
        var object = toObject(this), self = splitString && "[object String]" == _toString(this) ? this.split("") : object, length = self.length >>> 0, thisp = arguments[1];
        // If no callback function or if callback is not a callable function
        if ("[object Function]" != _toString(fun)) throw new TypeError(fun + " is not a function");
        for (var i = 0; length > i; i++) if (i in self && fun.call(thisp, self[i], i, object)) return !0;
        return !1;
    }), // ES5 15.4.4.21
    // http://es5.github.com/#x15.4.4.21
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
    Array.prototype.reduce || (Array.prototype.reduce = function(fun) {
        var object = toObject(this), self = splitString && "[object String]" == _toString(this) ? this.split("") : object, length = self.length >>> 0;
        // If no callback function or if callback is not a callable function
        if ("[object Function]" != _toString(fun)) throw new TypeError(fun + " is not a function");
        // no value to return if no initial value and an empty array
        if (!length && 1 == arguments.length) throw new TypeError("reduce of empty array with no initial value");
        var result, i = 0;
        if (arguments.length >= 2) result = arguments[1]; else for (;;) {
            if (i in self) {
                result = self[i++];
                break;
            }
            // if array contains no values, no initial value to return
            if (++i >= length) throw new TypeError("reduce of empty array with no initial value");
        }
        for (;length > i; i++) i in self && (result = fun.call(void 0, result, self[i], i, object));
        return result;
    }), // ES5 15.4.4.22
    // http://es5.github.com/#x15.4.4.22
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
    Array.prototype.reduceRight || (Array.prototype.reduceRight = function(fun) {
        var object = toObject(this), self = splitString && "[object String]" == _toString(this) ? this.split("") : object, length = self.length >>> 0;
        // If no callback function or if callback is not a callable function
        if ("[object Function]" != _toString(fun)) throw new TypeError(fun + " is not a function");
        // no value to return if no initial value, empty array
        if (!length && 1 == arguments.length) throw new TypeError("reduceRight of empty array with no initial value");
        var result, i = length - 1;
        if (arguments.length >= 2) result = arguments[1]; else for (;;) {
            if (i in self) {
                result = self[i--];
                break;
            }
            // if array contains no values, no initial value to return
            if (--i < 0) throw new TypeError("reduceRight of empty array with no initial value");
        }
        if (0 > i) return result;
        do i in this && (result = fun.call(void 0, result, self[i], i, object)); while (i--);
        return result;
    }), // ES5 15.4.4.14
    // http://es5.github.com/#x15.4.4.14
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
    Array.prototype.indexOf && -1 == [ 0, 1 ].indexOf(1, 2) || (Array.prototype.indexOf = function(sought) {
        var self = splitString && "[object String]" == _toString(this) ? this.split("") : toObject(this), length = self.length >>> 0;
        if (!length) return -1;
        var i = 0;
        for (arguments.length > 1 && (i = toInteger(arguments[1])), // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i); length > i; i++) if (i in self && self[i] === sought) return i;
        return -1;
    }), // ES5 15.4.4.15
    // http://es5.github.com/#x15.4.4.15
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
    Array.prototype.lastIndexOf && -1 == [ 0, 1 ].lastIndexOf(0, -3) || (Array.prototype.lastIndexOf = function(sought) {
        var self = splitString && "[object String]" == _toString(this) ? this.split("") : toObject(this), length = self.length >>> 0;
        if (!length) return -1;
        var i = length - 1;
        for (arguments.length > 1 && (i = Math.min(i, toInteger(arguments[1]))), // handle negative indices
        i = i >= 0 ? i : length - Math.abs(i); i >= 0; i--) if (i in self && sought === self[i]) return i;
        return -1;
    }), !Object.keys) {
        // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
        var hasDontEnumBug = !0, dontEnums = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ], dontEnumsLength = dontEnums.length;
        for (var key in {
            toString: null
        }) hasDontEnumBug = !1;
        Object.keys = function keys(object) {
            if ("object" != typeof object && "function" != typeof object || null === object) throw new TypeError("Object.keys called on a non-object");
            var keys = [];
            for (var name in object) owns(object, name) && keys.push(name);
            if (hasDontEnumBug) for (var i = 0, ii = dontEnumsLength; ii > i; i++) {
                var dontEnum = dontEnums[i];
                owns(object, dontEnum) && keys.push(dontEnum);
            }
            return keys;
        };
    }
    //
    // Date
    // ====
    //
    // ES5 15.9.5.43
    // http://es5.github.com/#x15.9.5.43
    // This function returns a String value represent the instance in time
    // represented by this Date object. The format of the String is the Date Time
    // string format defined in 15.9.1.15. All fields are present in the String.
    // The time zone is always UTC, denoted by the suffix Z. If the time value of
    // this object is not a finite Number a RangeError exception is thrown.
    var negativeDate = -621987552e5, negativeYearString = "-000001";
    Date.prototype.toISOString && -1 !== new Date(negativeDate).toISOString().indexOf(negativeYearString) || (Date.prototype.toISOString = function() {
        var result, length, value, year, month;
        if (!isFinite(this)) throw new RangeError("Date.prototype.toISOString called on non-finite value.");
        for (year = this.getUTCFullYear(), month = this.getUTCMonth(), // see https://github.com/kriskowal/es5-shim/issues/111
        year += Math.floor(month / 12), month = (month % 12 + 12) % 12, // the date time string format is specified in 15.9.1.15.
        result = [ month + 1, this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds() ], 
        year = (0 > year ? "-" : year > 9999 ? "+" : "") + ("00000" + Math.abs(year)).slice(year >= 0 && 9999 >= year ? -4 : -6), 
        length = result.length; length--; ) value = result[length], // pad months, days, hours, minutes, and seconds to have two
        // digits.
        10 > value && (result[length] = "0" + value);
        // pad milliseconds to have three digits.
        return year + "-" + result.slice(0, 2).join("-") + "T" + result.slice(2).join(":") + "." + ("000" + this.getUTCMilliseconds()).slice(-3) + "Z";
    });
    // ES5 15.9.5.44
    // http://es5.github.com/#x15.9.5.44
    // This function provides a String representation of a Date object for use by
    // JSON.stringify (15.12.3).
    var dateToJSONIsSupported = !1;
    try {
        dateToJSONIsSupported = Date.prototype.toJSON && null === new Date(0/0).toJSON() && -1 !== new Date(negativeDate).toJSON().indexOf(negativeYearString) && Date.prototype.toJSON.call({
            // generic
            toISOString: function() {
                return !0;
            }
        });
    } catch (e) {}
    //
    // String
    // ======
    //
    // ES5 15.5.4.14
    // http://es5.github.com/#x15.5.4.14
    // [bugfix, chrome]
    // If separator is undefined, then the result array contains just one String,
    // which is the this value (converted to a String). If limit is not undefined,
    // then the output array is truncated so that it contains no more than limit
    // elements.
    // "0".split(undefined, 0) -> []
    if (dateToJSONIsSupported || (Date.prototype.toJSON = function() {
        // When the toJSON method is called with argument key, the following
        // steps are taken:
        // 1.  Let O be the result of calling ToObject, giving it the this
        // value as its argument.
        // 2. Let tv be toPrimitive(O, hint Number).
        var toISO, o = Object(this), tv = toPrimitive(o);
        // 3. If tv is a Number and is not finite, return null.
        if ("number" == typeof tv && !isFinite(tv)) return null;
        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
        if (// 4. Let toISO be the result of calling the [[Get]] internal method of
        // O with argument "toISOString".
        toISO = o.toISOString, "function" != typeof toISO) throw new TypeError("toISOString property is not callable");
        // 6. Return the result of calling the [[Call]] internal method of
        //  toISO with O as the this value and an empty argument list.
        return toISO.call(o);
    }), // XXX global assignment won't work in embeddings that use
    // an alternate object for the context.
    Date = function(NativeDate) {
        // Date.length === 7
        function Date(Y, M, D, h, m, s, ms) {
            var length = arguments.length;
            if (this instanceof NativeDate) {
                var date = 1 == length && String(Y) === Y ? // isString(Y)
                // We explicitly pass it through parse:
                new NativeDate(Date.parse(Y)) : // We have to manually make calls depending on argument
                // length here
                length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) : length >= 6 ? new NativeDate(Y, M, D, h, m, s) : length >= 5 ? new NativeDate(Y, M, D, h, m) : length >= 4 ? new NativeDate(Y, M, D, h) : length >= 3 ? new NativeDate(Y, M, D) : length >= 2 ? new NativeDate(Y, M) : length >= 1 ? new NativeDate(Y) : new NativeDate();
                // Prevent mixups with unfixed Date object
                return date.constructor = Date, date;
            }
            return NativeDate.apply(this, arguments);
        }
        function dayFromMonth(year, month) {
            var t = month > 1 ? 1 : 0;
            return months[month] + Math.floor((year - 1969 + t) / 4) - Math.floor((year - 1901 + t) / 100) + Math.floor((year - 1601 + t) / 400) + 365 * (year - 1970);
        }
        // 15.9.1.15 Date Time String Format.
        var isoDateExpression = new RegExp("^(\\d{4}|[+-]\\d{6})(?:-(\\d{2})(?:-(\\d{2})(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:(\\.\\d{1,}))?)?(Z|(?:([-+])(\\d{2}):(\\d{2})))?)?)?)?$"), months = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 ];
        // Copy any custom methods a 3rd party library may have added
        for (var key in NativeDate) Date[key] = NativeDate[key];
        // Copy "native" methods explicitly; they may be non-enumerable
        // Upgrade Date.parse to handle simplified ISO 8601 strings
        return Date.now = NativeDate.now, Date.UTC = NativeDate.UTC, Date.prototype = NativeDate.prototype, 
        Date.prototype.constructor = Date, Date.parse = function(string) {
            var match = isoDateExpression.exec(string);
            if (match) {
                // parse months, days, hours, minutes, seconds, and milliseconds
                // provide default values if necessary
                // parse the UTC offset component
                var result, year = Number(match[1]), month = Number(match[2] || 1) - 1, day = Number(match[3] || 1) - 1, hour = Number(match[4] || 0), minute = Number(match[5] || 0), second = Number(match[6] || 0), millisecond = Math.floor(1e3 * Number(match[7] || 0)), // When time zone is missed, local offset should be used
                // (ES 5.1 bug)
                // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                offset = !match[4] || match[8] ? 0 : Number(new NativeDate(1970, 0)), signOffset = "-" === match[9] ? 1 : -1, hourOffset = Number(match[10] || 0), minuteOffset = Number(match[11] || 0);
                // detect invalid offsets
                return (minute > 0 || second > 0 || millisecond > 0 ? 24 : 25) > hour && 60 > minute && 60 > second && 1e3 > millisecond && month > -1 && 12 > month && 24 > hourOffset && 60 > minuteOffset && day > -1 && day < dayFromMonth(year, month + 1) - dayFromMonth(year, month) && (result = 60 * (24 * (dayFromMonth(year, month) + day) + hour + hourOffset * signOffset), 
                result = 1e3 * (60 * (result + minute + minuteOffset * signOffset) + second) + millisecond + offset, 
                result >= -864e13 && 864e13 >= result) ? result : 0/0;
            }
            return NativeDate.parse.apply(this, arguments);
        }, Date;
    }(Date), // ES5 15.9.4.4
    // http://es5.github.com/#x15.9.4.4
    Date.now || (Date.now = function() {
        return new Date().getTime();
    }), //
    // Number
    // ======
    //
    // ES5.1 15.7.4.5
    // http://es5.github.com/#x15.7.4.5
    Number.prototype.toFixed && "0.000" === 8e-5.toFixed(3) && "0" !== .9.toFixed(0) && "1.25" === 1.255.toFixed(2) && "1000000000000000128" === 0xde0b6b3a7640080.toFixed(0) || // Hide these variables and functions
    !function() {
        function multiply(n, c) {
            for (var i = -1; ++i < size; ) c += n * data[i], data[i] = c % base, c = Math.floor(c / base);
        }
        function divide(n) {
            for (var i = size, c = 0; --i >= 0; ) c += data[i], data[i] = Math.floor(c / n), 
            c = c % n * base;
        }
        function toString() {
            for (var i = size, s = ""; --i >= 0; ) if ("" !== s || 0 === i || 0 !== data[i]) {
                var t = String(data[i]);
                "" === s ? s = t : s += "0000000".slice(0, 7 - t.length) + t;
            }
            return s;
        }
        function pow(x, n, acc) {
            return 0 === n ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
        }
        function log(x) {
            for (var n = 0; x >= 4096; ) n += 12, x /= 4096;
            for (;x >= 2; ) n += 1, x /= 2;
            return n;
        }
        var base, size, data;
        base = 1e7, size = 6, data = [ 0, 0, 0, 0, 0, 0 ], Number.prototype.toFixed = function(fractionDigits) {
            var f, x, s, m, e, z, j, k;
            if (// Test for NaN and round fractionDigits down
            f = Number(fractionDigits), f = f !== f ? 0 : Math.floor(f), 0 > f || f > 20) throw new RangeError("Number.toFixed called with invalid number of decimals");
            // Test for NaN
            if (x = Number(this), x !== x) return "NaN";
            // If it is too big or small, return the string value of the number
            if (-1e21 >= x || x >= 1e21) return String(x);
            if (s = "", 0 > x && (s = "-", x = -x), m = "0", x > 1e-21) // -18 < e < 122
            // x = z / 2 ^ e
            if (// 1e-21 < x < 1e21
            // -70 < log2(x) < 70
            e = log(x * pow(2, 69, 1)) - 69, z = 0 > e ? x * pow(2, -e, 1) : x / pow(2, e, 1), 
            z *= 4503599627370496, // Math.pow(2, 52);
            e = 52 - e, e > 0) {
                for (multiply(0, z), j = f; j >= 7; ) multiply(1e7, 0), j -= 7;
                for (multiply(pow(10, j, 1), 0), j = e - 1; j >= 23; ) divide(1 << 23), j -= 23;
                divide(1 << j), multiply(1, 1), divide(2), m = toString();
            } else multiply(0, z), multiply(1 << -e, 0), m = toString() + "0.00000000000000000000".slice(2, 2 + f);
            return f > 0 ? (k = m.length, m = f >= k ? s + "0.0000000000000000000".slice(0, f - k + 2) + m : s + m.slice(0, k - f) + "." + m.slice(k - f)) : m = s + m, 
            m;
        };
    }(), "0".split(void 0, 0).length) {
        var string_split = String.prototype.split;
        String.prototype.split = function(separator, limit) {
            return void 0 === separator && 0 === limit ? [] : string_split.apply(this, arguments);
        };
    }
    // ECMA-262, 3rd B.2.3
    // Note an ECMAScript standart, although ECMAScript 3rd Edition has a
    // non-normative section suggesting uniform semantics and it should be
    // normalized across all browsers
    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
    if ("".substr && "b" !== "0b".substr(-1)) {
        var string_substr = String.prototype.substr;
        /**
     *  Get the substring of a string
     *  @param  {integer}  start   where to start the substring
     *  @param  {integer}  length  how many characters to return
     *  @return {string}
     */
        String.prototype.substr = function(start, length) {
            return string_substr.call(this, 0 > start && (start = this.length + start) < 0 ? 0 : start, length);
        };
    }
    // ES5 15.5.4.20
    // http://es5.github.com/#x15.5.4.20
    var ws = "	\n\f\r   ᠎             　\u2028\u2029﻿";
    if (!String.prototype.trim || ws.trim()) {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        // http://perfectionkills.com/whitespace-deviations/
        ws = "[" + ws + "]";
        var trimBeginRegexp = new RegExp("^" + ws + ws + "*"), trimEndRegexp = new RegExp(ws + ws + "*$");
        String.prototype.trim = function() {
            if (void 0 === this || null === this) throw new TypeError("can't convert " + this + " to object");
            return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
        };
    }
    // ES5 9.9
    // http://es5.github.com/#x9.9
    var toObject = function(o) {
        if (null == o) // this matches both null and undefined
        throw new TypeError("can't convert " + o + " to object");
        return Object(o);
    };
}), function(window) {
    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
        if (has[name] !== undef) // Return cached feature test result.
        return has[name];
        var isSupported;
        if ("bug-string-char-index" == name) // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a" != "a"[0]; else if ("json" == name) // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse"); else {
            var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
            // Test `JSON.stringify`.
            if ("json-stringify" == name) {
                var stringify = JSON3.stringify, stringifySupported = "function" == typeof stringify && isExtended;
                if (stringifySupported) {
                    // A test function object with a custom `toJSON` method.
                    (value = function() {
                        return 1;
                    }).toJSON = value;
                    try {
                        stringifySupported = // Firefox 3.1b1 and b2 serialize string, number, and boolean
                        // primitives as object literals.
                        "0" === stringify(0) && // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                        // literals.
                        "0" === stringify(new Number()) && '""' == stringify(new String()) && // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                        // does not define a canonical JSON representation (this applies to
                        // objects with `toJSON` properties as well, *unless* they are nested
                        // within an object or array).
                        stringify(getClass) === undef && // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                        // FF 3.1b3 pass this test.
                        stringify(undef) === undef && // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                        // respectively, if the value is omitted entirely.
                        stringify() === undef && // FF 3.1b1, 2 throw an error if the given value is not a number,
                        // string, array, object, Boolean, or `null` literal. This applies to
                        // objects with custom `toJSON` methods as well, unless they are nested
                        // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                        // methods entirely.
                        "1" === stringify(value) && "[1]" == stringify([ value ]) && // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                        // `"[null]"`.
                        "[null]" == stringify([ undef ]) && // YUI 3.0.0b1 fails to serialize `null` literals.
                        "null" == stringify(null) && // FF 3.1b1, 2 halts serialization if an array contains a function:
                        // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                        // elides non-JSON values from objects and arrays, unless they
                        // define custom `toJSON` methods.
                        "[null,null,null]" == stringify([ undef, getClass, null ]) && // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                        // where character escape codes are expected (e.g., `\b` => `\u0008`).
                        stringify({
                            a: [ value, !0, !1, null, "\x00\b\n\f\r	" ]
                        }) == serialized && // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                        "1" === stringify(null, value) && "[\n 1,\n 2\n]" == stringify([ 1, 2 ], null, 1) && // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                        // serialize extended years.
                        '"-271821-04-20T00:00:00.000Z"' == stringify(new Date(-864e13)) && // The milliseconds are optional in ES 5, but required in 5.1.
                        '"+275760-09-13T00:00:00.000Z"' == stringify(new Date(864e13)) && // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                        // four-digit years instead of six-digit years. Credits: @Yaffle.
                        '"-000001-01-01T00:00:00.000Z"' == stringify(new Date(-621987552e5)) && // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                        // values less than 1000. Credits: @Yaffle.
                        '"1969-12-31T23:59:59.999Z"' == stringify(new Date(-1));
                    } catch (exception) {
                        stringifySupported = !1;
                    }
                }
                isSupported = stringifySupported;
            }
            // Test `JSON.parse`.
            if ("json-parse" == name) {
                var parse = JSON3.parse;
                if ("function" == typeof parse) try {
                    // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                    // Conforming implementations should also coerce the initial argument to
                    // a string prior to parsing.
                    if (0 === parse("0") && !parse(!1)) {
                        // Simple parsing test.
                        value = parse(serialized);
                        var parseSupported = 5 == value.a.length && 1 === value.a[0];
                        if (parseSupported) {
                            try {
                                // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                                parseSupported = !parse('"	"');
                            } catch (exception) {}
                            if (parseSupported) try {
                                // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                                // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                                // certain octal literals.
                                parseSupported = 1 !== parse("01");
                            } catch (exception) {}
                            if (parseSupported) try {
                                // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                                // points. These environments, along with FF 3.1b1 and 2,
                                // also allow trailing commas in JSON objects and arrays.
                                parseSupported = 1 !== parse("1.");
                            } catch (exception) {}
                        }
                    }
                } catch (exception) {
                    parseSupported = !1;
                }
                isSupported = parseSupported;
            }
        }
        return has[name] = !!isSupported;
    }
    // Convenience aliases.
    var isProperty, forEach, undef, getClass = {}.toString, isLoader = "function" == typeof define && define.amd, nativeJSON = "object" == typeof JSON && JSON, JSON3 = "object" == typeof exports && exports && !exports.nodeType && exports;
    JSON3 && nativeJSON ? (// Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify, JSON3.parse = nativeJSON.parse) : // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-0xc782b5b800cec);
    try {
        // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
        // results for certain dates in Opera >= 10.53.
        isExtended = -109252 == isExtended.getUTCFullYear() && 0 === isExtended.getUTCMonth() && 1 === isExtended.getUTCDate() && // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        10 == isExtended.getUTCHours() && 37 == isExtended.getUTCMinutes() && 6 == isExtended.getUTCSeconds() && 708 == isExtended.getUTCMilliseconds();
    } catch (exception) {}
    if (!has("json")) {
        // Common `[[Class]]` name aliases.
        var functionClass = "[object Function]", dateClass = "[object Date]", numberClass = "[object Number]", stringClass = "[object String]", arrayClass = "[object Array]", booleanClass = "[object Boolean]", charIndexBuggy = has("bug-string-char-index");
        // Define additional utility methods if the `Date` methods are buggy.
        if (!isExtended) var floor = Math.floor, Months = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ], getDay = function(year, month) {
            return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
        // Internal: Determines if a property is a direct property of the given
        // object. Delegates to the native `Object#hasOwnProperty` method.
        (isProperty = {}.hasOwnProperty) || (isProperty = function(property) {
            var constructor, members = {};
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            // Capture a reference to the top-level `Object` constructor.
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            return (members.__proto__ = null, members.__proto__ = {
                // The *proto* property cannot be set multiple times in recent
                // versions of Firefox and SeaMonkey.
                toString: 1
            }, members).toString != getClass ? isProperty = function(property) {
                // Capture and break the object's prototype chain (see section 8.6.2
                // of the ES 5.1 spec). The parenthesized expression prevents an
                // unsafe transformation by the Closure Compiler.
                var original = this.__proto__, result = property in (this.__proto__ = null, this);
                // Restore the original prototype chain.
                return this.__proto__ = original, result;
            } : (constructor = members.constructor, isProperty = function(property) {
                var parent = (this.constructor || constructor).prototype;
                return property in this && !(property in parent && this[property] === parent[property]);
            }), members = null, isProperty.call(this, property);
        });
        // Internal: A set of primitive types used by `isHostType`.
        var PrimitiveTypes = {
            "boolean": 1,
            number: 1,
            string: 1,
            undefined: 1
        }, isHostType = function(object, property) {
            var type = typeof object[property];
            return "object" == type ? !!object[property] : !PrimitiveTypes[type];
        };
        // Public: Serializes a JavaScript `value` as a JSON string. The optional
        // `filter` argument may specify either a function that alters how object and
        // array members are serialized, or an array of strings and numbers that
        // indicates which properties should be serialized. The optional `width`
        // argument may be either a string or number that specifies the indentation
        // level of the output.
        if (// Internal: Normalizes the `for...in` iteration algorithm across
        // environments. Each enumerated key is yielded to a `callback` function.
        forEach = function(object, callback) {
            var Properties, members, property, size = 0;
            // Tests for bugs in the current environment's `for...in` algorithm. The
            // `valueOf` property inherits the non-enumerable flag from
            // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
            (Properties = function() {
                this.valueOf = 0;
            }).prototype.valueOf = 0, // Iterate over a new instance of the `Properties` class.
            members = new Properties();
            for (property in members) // Ignore all properties inherited from `Object.prototype`.
            isProperty.call(members, property) && size++;
            // Normalize the iteration algorithm.
            // Safari <= 2.0.4 enumerates shadowed properties twice.
            // A list of non-enumerable properties inherited from `Object.prototype`.
            // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
            // properties.
            return Properties = members = null, size ? forEach = 2 == size ? function(object, callback) {
                // Create a set of iterated properties.
                var property, members = {}, isFunction = getClass.call(object) == functionClass;
                for (property in object) // Store each property name to prevent double enumeration. The
                // `prototype` property of functions is not enumerated due to cross-
                // environment inconsistencies.
                isFunction && "prototype" == property || isProperty.call(members, property) || !(members[property] = 1) || !isProperty.call(object, property) || callback(property);
            } : function(object, callback) {
                var property, isConstructor, isFunction = getClass.call(object) == functionClass;
                for (property in object) isFunction && "prototype" == property || !isProperty.call(object, property) || (isConstructor = "constructor" === property) || callback(property);
                // Manually invoke the callback for the `constructor` property due to
                // cross-environment inconsistencies.
                (isConstructor || isProperty.call(object, property = "constructor")) && callback(property);
            } : (members = [ "valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor" ], 
            forEach = function(object, callback) {
                var property, length, isFunction = getClass.call(object) == functionClass, hasProperty = !isFunction && "function" != typeof object.constructor && isHostType(object, "hasOwnProperty") ? object.hasOwnProperty : isProperty;
                for (property in object) // Gecko <= 1.0 enumerates the `prototype` property of functions under
                // certain conditions; IE does not.
                isFunction && "prototype" == property || !hasProperty.call(object, property) || callback(property);
                // Manually invoke the callback for each non-enumerable property.
                for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) ;
            }), forEach(object, callback);
        }, !has("json-stringify")) {
            // Internal: A map of control characters and their escaped equivalents.
            var Escapes = {
                92: "\\\\",
                34: '\\"',
                8: "\\b",
                12: "\\f",
                10: "\\n",
                13: "\\r",
                9: "\\t"
            }, leadingZeroes = "000000", toPaddedString = function(width, value) {
                // The `|| 0` expression is necessary to work around a bug in
                // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
                return (leadingZeroes + (value || 0)).slice(-width);
            }, unicodePrefix = "\\u00", quote = function(value) {
                var symbols, result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy;
                for (isLarge && (symbols = value.split("")); length > index; index++) {
                    var charCode = value.charCodeAt(index);
                    // If the character is a control character, append its Unicode or
                    // shorthand escape sequence; otherwise, append the character as-is.
                    switch (charCode) {
                      case 8:
                      case 9:
                      case 10:
                      case 12:
                      case 13:
                      case 34:
                      case 92:
                        result += Escapes[charCode];
                        break;

                      default:
                        if (32 > charCode) {
                            result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                            break;
                        }
                        result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
                    }
                }
                return result + '"';
            }, serialize = function(property, object, callback, properties, whitespace, indentation, stack) {
                var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
                try {
                    // Necessary for host object support.
                    value = object[property];
                } catch (exception) {}
                if ("object" == typeof value && value) if (className = getClass.call(value), className != dateClass || isProperty.call(value, "toJSON")) "function" == typeof value.toJSON && (className != numberClass && className != stringClass && className != arrayClass || isProperty.call(value, "toJSON")) && (// Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
                // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
                // ignores all `toJSON` methods on these objects unless they are
                // defined directly on an instance.
                value = value.toJSON(property)); else if (value > -1 / 0 && 1 / 0 > value) {
                    // Dates are serialized according to the `Date#toJSON` method
                    // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                    // for the ISO 8601 date time string format.
                    if (getDay) {
                        for (// Manually compute the year, month, date, hours, minutes,
                        // seconds, and milliseconds if the `getUTC*` methods are
                        // buggy. Adapted from @Yaffle's `date-shim` project.
                        date = floor(value / 864e5), year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) ;
                        for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) ;
                        date = 1 + date - getDay(year, month), // The `time` value specifies the time within the day (see ES
                        // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                        // to compute `A modulo B`, as the `%` operator does not
                        // correspond to the `modulo` operation for negative numbers.
                        time = (value % 864e5 + 864e5) % 864e5, // The hours, minutes, seconds, and milliseconds are obtained by
                        // decomposing the time within the day. See section 15.9.1.10.
                        hours = floor(time / 36e5) % 24, minutes = floor(time / 6e4) % 60, seconds = floor(time / 1e3) % 60, 
                        milliseconds = time % 1e3;
                    } else year = value.getUTCFullYear(), month = value.getUTCMonth(), date = value.getUTCDate(), 
                    hours = value.getUTCHours(), minutes = value.getUTCMinutes(), seconds = value.getUTCSeconds(), 
                    milliseconds = value.getUTCMilliseconds();
                    // Serialize extended years correctly.
                    value = (0 >= year || year >= 1e4 ? (0 > year ? "-" : "+") + toPaddedString(6, 0 > year ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + // Months, dates, hours, minutes, and seconds should have two
                    // digits; milliseconds should have three.
                    "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + // Milliseconds are optional in ES 5.0, but required in 5.1.
                    "." + toPaddedString(3, milliseconds) + "Z";
                } else value = null;
                if (callback && (// If a replacement function was provided, call it to obtain the value
                // for serialization.
                value = callback.call(object, property, value)), null === value) return "null";
                if (className = getClass.call(value), className == booleanClass) // Booleans are represented literally.
                return "" + value;
                if (className == numberClass) // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                // `"null"`.
                return value > -1 / 0 && 1 / 0 > value ? "" + value : "null";
                if (className == stringClass) // Strings are double-quoted and escaped.
                return quote("" + value);
                // Recursively serialize objects and arrays.
                if ("object" == typeof value) {
                    // Check for cyclic structures. This is a linear search; performance
                    // is inversely proportional to the number of unique nested objects.
                    for (length = stack.length; length--; ) if (stack[length] === value) // Cyclic structures cannot be serialized by `JSON.stringify`.
                    throw TypeError();
                    if (// Add the object to the stack of traversed objects.
                    stack.push(value), results = [], // Save the current indentation level and indent one additional level.
                    prefix = indentation, indentation += whitespace, className == arrayClass) {
                        // Recursively serialize array elements.
                        for (index = 0, length = value.length; length > index; index++) element = serialize(index, value, callback, properties, whitespace, indentation, stack), 
                        results.push(element === undef ? "null" : element);
                        result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
                    } else // Recursively serialize object members. Members are selected from
                    // either a user-specified list of property names, or the object
                    // itself.
                    forEach(properties || value, function(property) {
                        var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                        element !== undef && // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                        // is not the empty string, let `member` {quote(property) + ":"}
                        // be the concatenation of `member` and the `space` character."
                        // The "`space` character" refers to the literal space
                        // character, not the `space` {width} argument provided to
                        // `JSON.stringify`.
                        results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                    }), result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
                    // Remove the object from the traversed object stack.
                    return stack.pop(), result;
                }
            };
            // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
            JSON3.stringify = function(source, filter, width) {
                var whitespace, callback, properties, className;
                if ("function" == typeof filter || "object" == typeof filter && filter) if ((className = getClass.call(filter)) == functionClass) callback = filter; else if (className == arrayClass) {
                    // Convert the property names array into a makeshift set.
                    properties = {};
                    for (var value, index = 0, length = filter.length; length > index; value = filter[index++], 
                    className = getClass.call(value), (className == stringClass || className == numberClass) && (properties[value] = 1)) ;
                }
                if (width) if ((className = getClass.call(width)) == numberClass) {
                    // Convert the `width` to an integer and create a string containing
                    // `width` number of space characters.
                    if ((width -= width % 1) > 0) for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") ;
                } else className == stringClass && (whitespace = width.length <= 10 ? width : width.slice(0, 10));
                // Opera <= 7.54u2 discards the values associated with empty string keys
                // (`""`) only if they are used directly within an object member list
                // (e.g., `!("" in { "": 1})`).
                return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
            };
        }
        // Public: Parses a JSON source string.
        if (!has("json-parse")) {
            var Index, Source, fromCharCode = String.fromCharCode, Unescapes = {
                92: "\\",
                34: '"',
                47: "/",
                98: "\b",
                116: "	",
                110: "\n",
                102: "\f",
                114: "\r"
            }, abort = function() {
                throw Index = Source = null, SyntaxError();
            }, lex = function() {
                for (var value, begin, position, isSigned, charCode, source = Source, length = source.length; length > Index; ) switch (charCode = source.charCodeAt(Index)) {
                  case 9:
                  case 10:
                  case 13:
                  case 32:
                    // Skip whitespace tokens, including tabs, carriage returns, line
                    // feeds, and space characters.
                    Index++;
                    break;

                  case 123:
                  case 125:
                  case 91:
                  case 93:
                  case 58:
                  case 44:
                    // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                    // the current position.
                    return value = charIndexBuggy ? source.charAt(Index) : source[Index], Index++, value;

                  case 34:
                    // `"` delimits a JSON string; advance to the next character and
                    // begin parsing the string. String tokens are prefixed with the
                    // sentinel `@` character to distinguish them from punctuators and
                    // end-of-string tokens.
                    for (value = "@", Index++; length > Index; ) if (charCode = source.charCodeAt(Index), 
                    32 > charCode) // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort(); else if (92 == charCode) switch (// A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index)) {
                      case 92:
                      case 34:
                      case 47:
                      case 98:
                      case 116:
                      case 110:
                      case 102:
                      case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode], Index++;
                        break;

                      case 117:
                        for (// `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index, position = Index + 4; position > Index; Index++) charCode = source.charCodeAt(Index), 
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        charCode >= 48 && 57 >= charCode || charCode >= 97 && 102 >= charCode || charCode >= 65 && 70 >= charCode || // Invalid Unicode escape sequence.
                        abort();
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;

                      default:
                        // Invalid escape sequence.
                        abort();
                    } else {
                        if (34 == charCode) // An unescaped double-quote character marks the end of the
                        // string.
                        break;
                        // Optimize for the common case where a string is valid.
                        for (charCode = source.charCodeAt(Index), begin = Index; charCode >= 32 && 92 != charCode && 34 != charCode; ) charCode = source.charCodeAt(++Index);
                        // Append the string as-is.
                        value += source.slice(begin, Index);
                    }
                    if (34 == source.charCodeAt(Index)) // Advance to the next character and return the revived string.
                    return Index++, value;
                    // Unterminated string.
                    abort();

                  default:
                    // Parse an integer or floating-point value.
                    if (// Parse numbers and literals.
                    begin = Index, // Advance past the negative sign, if one is specified.
                    45 == charCode && (isSigned = !0, charCode = source.charCodeAt(++Index)), charCode >= 48 && 57 >= charCode) {
                        // Parse the integer component.
                        for (// Leading zeroes are interpreted as octal literals.
                        48 == charCode && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && 57 >= charCode) && // Illegal octal literal.
                        abort(), isSigned = !1; length > Index && (charCode = source.charCodeAt(Index), 
                        charCode >= 48 && 57 >= charCode); Index++) ;
                        // Floats cannot contain a leading decimal point; however, this
                        // case is already accounted for by the parser.
                        if (46 == source.charCodeAt(Index)) {
                            // Parse the decimal component.
                            for (position = ++Index; length > position && (charCode = source.charCodeAt(position), 
                            charCode >= 48 && 57 >= charCode); position++) ;
                            position == Index && // Illegal trailing decimal.
                            abort(), Index = position;
                        }
                        if (// Parse exponents. The `e` denoting the exponent is
                        // case-insensitive.
                        charCode = source.charCodeAt(Index), 101 == charCode || 69 == charCode) {
                            // Parse the exponential component.
                            for (charCode = source.charCodeAt(++Index), // Skip past the sign following the exponent, if one is
                            // specified.
                            (43 == charCode || 45 == charCode) && Index++, position = Index; length > position && (charCode = source.charCodeAt(position), 
                            charCode >= 48 && 57 >= charCode); position++) ;
                            position == Index && // Illegal empty exponent.
                            abort(), Index = position;
                        }
                        // Coerce the parsed value to a JavaScript number.
                        return +source.slice(begin, Index);
                    }
                    // `true`, `false`, and `null` literals.
                    if (// A negative sign may only precede numbers.
                    isSigned && abort(), "true" == source.slice(Index, Index + 4)) return Index += 4, 
                    !0;
                    if ("false" == source.slice(Index, Index + 5)) return Index += 5, !1;
                    if ("null" == source.slice(Index, Index + 4)) return Index += 4, null;
                    // Unrecognized token.
                    abort();
                }
                // Return the sentinel `$` character if the parser has reached the end
                // of the source string.
                return "$";
            }, get = function(value) {
                var results, hasMembers;
                if ("$" == value && // Unexpected end of input.
                abort(), "string" == typeof value) {
                    if ("@" == (charIndexBuggy ? value.charAt(0) : value[0])) // Remove the sentinel `@` character.
                    return value.slice(1);
                    // Parse object and array literals.
                    if ("[" == value) {
                        for (// Parses a JSON array, returning a new JavaScript array.
                        results = []; value = lex(), "]" != value; hasMembers || (hasMembers = !0)) // If the array literal contains elements, the current token
                        // should be a comma separating the previous element from the
                        // next.
                        hasMembers && ("," == value ? (value = lex(), "]" == value && // Unexpected trailing `,` in array literal.
                        abort()) : // A `,` must separate each array element.
                        abort()), // Elisions and leading commas are not permitted.
                        "," == value && abort(), results.push(get(value));
                        return results;
                    }
                    if ("{" == value) {
                        for (// Parses a JSON object, returning a new JavaScript object.
                        results = {}; value = lex(), "}" != value; hasMembers || (hasMembers = !0)) // If the object literal contains members, the current token
                        // should be a comma separator.
                        hasMembers && ("," == value ? (value = lex(), "}" == value && // Unexpected trailing `,` in object literal.
                        abort()) : // A `,` must separate each object member.
                        abort()), // Leading commas are not permitted, object property names must be
                        // double-quoted strings, and a `:` must separate each property
                        // name and value.
                        ("," == value || "string" != typeof value || "@" != (charIndexBuggy ? value.charAt(0) : value[0]) || ":" != lex()) && abort(), 
                        results[value.slice(1)] = get(lex());
                        return results;
                    }
                    // Unexpected token encountered.
                    abort();
                }
                return value;
            }, update = function(source, property, callback) {
                var element = walk(source, property, callback);
                element === undef ? delete source[property] : source[property] = element;
            }, walk = function(source, property, callback) {
                var length, value = source[property];
                if ("object" == typeof value && value) // `forEach` can't be used to traverse an array in Opera <= 8.54
                // because its `Object#hasOwnProperty` implementation returns `false`
                // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                if (getClass.call(value) == arrayClass) for (length = value.length; length--; ) update(value, length, callback); else forEach(value, function(property) {
                    update(value, property, callback);
                });
                return callback.call(source, property, value);
            };
            // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
            JSON3.parse = function(source, callback) {
                var result, value;
                // If a JSON string contains multiple tokens, it is invalid.
                // Reset the parser state.
                return Index = 0, Source = "" + source, result = get(lex()), "$" != lex() && abort(), 
                Index = Source = null, callback && getClass.call(callback) == functionClass ? walk((value = {}, 
                value[""] = result, value), "", callback) : result;
            };
        }
    }
    // Export for asynchronous module loaders.
    isLoader && define(function() {
        return JSON3;
    });
}(this);
//# sourceMappingURL=gltextarea.ie_polyfills.min.js.map